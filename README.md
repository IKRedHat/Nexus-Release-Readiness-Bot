Nexus: Multi-Agent Release Automation System

Nexus is a cutting-edge, multi-agent automation system designed to revolutionize software Release Management. Built on a Managed Compute Platform (MCP) architecture, Nexus uses a Central Orchestrator powered by the ReAct (Reasoning and Acting) framework to coordinate specialized agents, automating everything from weekly status nudges to complex Go/No-Go decision reports.

ğŸ§  System Architecture

Nexus operates on a hub-and-spoke model where a Central Orchestrator serves as the "brain," delegating tasks to specialized agents that interface with external tools.

Component

Responsibility

Tech Stack

Central Orchestrator

ReAct planning engine, context management, and routing.

Python (FastAPI), Gemini API

Slack Agent

Conversational interface, slash commands, and interactive modals.

Slack Bolt SDK

Jira Agent

Ticket management, hierarchical summaries (Task -> Epic).

Jira Cloud API

Git/CI Agent

Build triggers, branch management, and security scanning.

GitHub/Jenkins APIs

Reporting Agent

Generates Confluence Go/No-Go reports and aggregates evidence.

Confluence API

Data Layer

RAG Memory (Vector DB) and State Management.

PostgreSQL, Vector DB

âœ¨ Key Features

1. Conversational Core

Slack-First Workflow: Developers interact entirely via Slack using commands like /jira update or /jenkins build.

Interactive Modals: Update ticket status and add comments without leaving the chat.

2. Intelligent Automation

ReAct Planning: The Orchestrator dynamically determines which agents to call based on natural language queries (e.g., "Check the status of the payment service release and look for any blockers").

RAG-Powered Search: Grounded answers to questions like "Why did the Q3 release fail?" using historical data from Jira and Confluence.

3. Automated Reporting

Hierarchical Summaries: Uses LLMs to summarize child tasks into Epic descriptions and Epics into Strategic updates.

One-Click Go/No-Go: Automatically compiles security scores, test results, and outstanding blockers into a Confluence decision document.

ğŸ“‚ Repository Structure

This project follows a Monorepo pattern for easier dependency management and synchronized deployments.

nexus-automation/
â”œâ”€â”€ .github/workflows/          # CI/CD Pipelines
â”œâ”€â”€ infrastructure/             # Terraform & Docker configuration
â”‚   â”œâ”€â”€ terraform/              # Cloud provisioning (Cloud Run, SQL)
â”‚   â””â”€â”€ docker/                 # Dockerfiles for Orchestrator & Agents
â”œâ”€â”€ services/                   # Microservices Source Code
â”‚   â”œâ”€â”€ orchestrator/           # Central Intelligence (FastAPI + ReAct)
â”‚   â””â”€â”€ agents/                 # Specialized Tool Agents (Jira, Git, Slack, etc.)
â”œâ”€â”€ shared/nexus_lib/           # Shared Schemas & API Contracts
â”œâ”€â”€ tests/e2e/                  # Integration Tests
â””â”€â”€ scripts/                    # Setup and Utility Scripts


ğŸš€ Quick Start

Prerequisites

Python 3.11+

Docker & Docker Compose

Git

1. Installation

Clone the repository and set up the environment:

git clone [https://github.com/IKRedHat/Nexus-Release-Readiness-Bot.git](https://github.com/IKRedHat/Nexus-Release-Readiness-Bot.git)
cd Nexus-Release-Readiness-Bot


2. Setup & Code Injection

If you are initializing this project from scratch, use the included scripts to generate the directory structure and MVP code:

# 1. Create folder structure
chmod +x setup_repo.sh
./setup_repo.sh

# 2. Inject MVP functional code (Orchestrator, Shared Libs, Terraform)
chmod +x install_nexus_code.sh
./install_nexus_code.sh


3. Run Local Demo

Test the ReAct Engine logic locally without deploying to the cloud:

chmod +x run_mvp_demo.sh
./run_mvp_demo.sh


This demo script will:

Set up a local virtual environment.

Start the Central Orchestrator service in the background.

Simulate user commands (e.g., /jira status, /search-rm) via CURL.

Display the ReAct plan generated by the Orchestrator.

ğŸ—ºï¸ Roadmap

Phase 0: Foundation (Current) - Infrastructure setup, Auth, and API Contracts.

Phase 1: Conversational Core - Full Slack integration and basic Jira updates.

Phase 2: Intelligence - Vector DB implementation and ReAct grounded search.

Phase 3: Automation - Scheduling agent and automated Confluence reporting.

ğŸ¤ Contributing

Fork the repository.

Create a feature branch (git checkout -b feature/amazing-feature).

Commit your changes (git commit -m 'Add some amazing feature').

Push to the branch (git push origin feature/amazing-feature).

Open a Pull Request.

ğŸ“„ License

Distributed under the MIT License. See LICENSE for more information.
