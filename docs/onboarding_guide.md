Nexus Engineering Onboarding Guide üß≠Welcome to the Team! This document simplifies the Nexus codebase so you can understand how it works and start contributing quickly.1. What is Nexus? (The 30-Second Pitch)Imagine you have a super-smart assistant in Slack. You ask it: "Is the release ready?"Instead of just searching keywords, this assistant:Thinks about your question ("I need to check Jira and Jenkins").Acts by reaching out to those tools securely.Summarizes the results into a clean report.Nexus isn't just a chatbot; it's a Multi-Agent System. It has a "Brain" (the Orchestrator) and several "Hands" (Specialized Agents) that do the actual work.2. The Architecture: Hub-and-SpokeWe use a Monorepo structure, meaning all our services live in one Git repository. It‚Äôs organized like a wheel:The Hub (Orchestrator): The central decision-maker. It receives your Slack message, uses AI to plan a path, and tells the agents what to do.The Spokes (Agents): Small, focused services. One only talks to Jira. One only talks to GitHub. They don't know about each other; they only talk to the Hub.3. Navigating the Code (/services)This is where 90% of your work will happen. Each folder here is a separate microservice.üß† services/orchestrator/ (The Brain)What it does: Receives commands, maintains memory (History), and runs the "Reasoning Loop" (ReAct/LangGraph).Key File: app/core/react_engine.py or graph.py. This is where the AI logic lives. It says: "The user asked for X, so I need to call Tool Y."Tech: Python, FastAPI, Gemini AI.ü§ñ services/agents/ (The Hands)Each folder here is a mini-server that wraps an external API.jira_agent/: Can fetch ticket hierarchies and update status. It translates "Get Ticket 123" into complex Atlassian API calls.git_ci_agent/: Can trigger Jenkins builds or check GitHub PRs.slack_agent/: The "ears" of the system. It listens to Slack events and forwards them to the Orchestrator.reporting_agent/: A specialist that just takes data and formats it into beautiful HTML reports for Confluence.‚öôÔ∏è services/admin_dashboard/ (The Control Panel)What it does: A web UI to manage settings (like API keys) so you don't have to restart servers to change a password.Tech: React (Frontend) + FastAPI (Backend).4. The Glue (/shared)üì¶ shared/nexus_lib/To stop us from writing the same code 5 times, we put common logic here.schemas/: These are the "Contracts". For example, we define exactly what a JiraTicket looks like here. Both the Orchestrator and Jira Agent import this, so they never misunderstand each other.middleware.py: Handles security (checking tokens) and metrics (counting requests) automatically for every service.5. How It Runs (/infrastructure)We don't run these scripts manually. We use Docker, which is like packing each service into its own tidy box with everything it needs installed.docker-compose.yml: This file is magic. It describes our whole world. When you run docker-compose up, it:Starts a Postgres database (for saving state).Starts a Redis cache (for fast configuration).Spins up the Orchestrator and all 5 Agents.Connects them all on a private network.6. Your First ContributionReady to write code? Here is the flow:Pick a Card: Find a Jira ticket (e.g., "Add support for Trello").Create the Agent: Copy the jira_agent folder and rename it trello_agent.Define the Contract: Go to shared/nexus_lib/schemas and define what a TrelloCard looks like.Implement Logic: In your new agent, write the code to talk to Trello's API using our AsyncHttpClient wrapper.Register: Add your new agent to docker-compose.yml and tell the Orchestrator it exists.Test: Run ./setup_local_env.sh and then docker-compose up.Pro Tip: If you get stuck, check the tests/ folder. We have "End-to-End" (E2E) tests that show exactly how a request flows from start to finish!
